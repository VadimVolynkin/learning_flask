# OFFICIAL DOCS
https://palletsprojects.com/p/flask/

# pipenv install Flask

# ============================================================================================================================
# ШАБЛОНИЗАЦИЯ
# ============================================================================================================================
по умолчанию все шаблоны берутся из подкаталога templates программы или пакета

return render_template("register.html", menu=dbase.getMenu(), title="Регистрация")

# ============================================================================================================================
# КАК РАБОТАЕТ ФЛАСК
# ============================================================================================================================
Сервер получает запрос от клиента - сначала может быть создан контекст приложения
Затем обязательно создается контекст запроса - фактическое представление (обработчик) текущего запроса


# ===== КОНТЕКСТ ПРИЛОЖЕНИЯ(создается если используется)

g 
# общая временная пользовательская информация для обработки запроса. После обработки запроса данные g удаляются.
# в нее обычно записывается установленное соединение с БД

current_app
# ссылка на контекст текущего приложения


# ===== КОНТЕКСТ ЗАПРОСА(создается всегда после контекста приложения)

request
# данные, связанные с пришедшим запросом, включая текущий URL
# часто – это данные GET-запроса в формате: ключ-значение
# request доступна во всех функциях текущего потока (текущего представления) и шаблонах

session
# словарь, в котором можно сохранять данные в пределах сессии
# сессия сохраняется между запросами и уникальна для каждого источника запроса
# у сессии есть время жизни, после чего она очищается. Время отсчитывается от последнего прихода запроса.


# ============================================================================================================================
# URL
# ============================================================================================================================

# ===== генерирует URL-адрес по имени функции-обработчика
url_for(endpoint, **values) 

# создание контекста запроса без активации веб-сервера
# позволет узнать сгенерированные url
with app.test_request_context():
    print(url_for('index'))
    print(url_for('profile', username="selfedu"))


# ===== создание url адреса с использованем переменных 
@app.route("/profile/<username>")
def profile(username):
    return f"Пользователь: {username}"

# можно указать использованием только целых чисел, иначе 404
# int – должны присутствовать только цифры;
# float – можно записывать число с плавающей точкой;
# path – можно использовать любые допустимые символы URL плюс символ слеша ‘/’. 
@app.route("/profile/<int:username>")


# ===== создание url для статических файлов в html шаблоне
# 'static'  вместо функции-обработчика говорит что нужно найти файл в папке static
<link type="text/css" href="{{ url_for('static', filename='css/styles.css')}}" rel="stylesheet" />


# ============================================================================================================================
# FORMS
# ============================================================================================================================

# ===== код формы
<form action="/contact" method="post" class="form-contact">
  <p><label>Имя: </label> <input type="text" name="username" value="" requied />
  <p><label>Email: </label> <input type="text" name="email" value="" requied />
  <p><label>Сообщение:</label>
  <p><textarea name="message" rows=7 cols=40></textarea>
  <p><input type="submit" value="Отправить" />
</form>

# action - URL, который принимает данные от формы

# method - способ передачи данных
GET – в виде строки запроса: "/handler?name=Alex&old=18&profit=1000"
POST – в виде бинарных данных (для передачи больших объемов данных: изображений, звуков, документов и т.п., а также закрытых сведений: паролей, логинов и т.п.)

# ===== код обработчика с указанием методов
@app.route("/contact", methods=["POST", "GET"])


# ===== дотуп к данным
print(request.form['username'])


# ============================================================================================================================
# Мгновенные сообщения - flash, get_flashed_messages
# ============================================================================================================================
# функции flash и get_flashed_messages используют механизм сессий(требуют настройки сессий)

flask.flash(message, category='message') 
# формирование сообщения пользователю
# message – текст сообщения
# category – категория сообщения

flask.get_flashed_messages(with_categories=False, category_filter=[])
# обработка сформированных сообщений в шаблоне документа
# with_categories – разрешает использование категорий при извлечении сообщений
# category_filter – список разрешенных категорий при выборке сообщений


# ============================================================================================================================
# Декоратор errorhandler, функции redirect и abort
# ============================================================================================================================

# декоратор указывает какой код ошибки он обрабатывает
# в этом случае сервер обработает 404 и вернет 200
@app.errorhandler(404)
def pageNotFount(error):
    return render_template('page404.html', title="Страница не найдена", menu=menu)
    # если надо вернуть 404
    # return render_template('page404.html', title="Страница не найдена", menu=menu), 404


# ============================================================================================================================
# РАБОТА С БД
# ============================================================================================================================
# при получении запроса создается соединение с базой данных и записывается в g
# после завершения обработки запроса соединение закрывается, g очищается

# ===== УСТАНОВКА СОЕДИНЕНИЯ

# установления соединения с БД
def connect_db():
    conn = sqlite3.connect(app.config['DATABASE'])
    conn.row_factory = sqlite3.Row
    return conn


# соединение с БД, если оно еще не установлено
def get_db():
    if not hasattr(g, 'link_db'):
        g.link_db = connect_db()
    return g.link_db


@app.route("/")
def index():
    # получаем объект базы и передаем его в класс для работы с запросами
    db = get_db()
    dbase = FDataBase(db)
    return render_template('index.html', menu=menu)


# ===== ЗАКРЫТИЕ СОЕДИНЕНИЯ

# Закрываем соединение с БД, если оно было установлено
# вызывается в момент уничтожения контекста приложения(в момент завершения обработки запроса)
@app.teardown_appcontext
def close_db(error):
    if hasattr(g, 'link_db'):
        g.link_db.close()



# ============================================================================================================================
# ДЕКОРАТОРЫ
# ============================================================================================================================

# выполняется до обработки первого запроса на сервере 1 раз
@app.before_first_request
def before_first_request():
    print('before_first_request')


# выполняется каждый раз до обработки текущего запроса
# здесь часто помещают создание соединения с базой
@app.before_request
def before_request():
    print('before_request')


# выполняется после обработки текущего запроса
# не вызывается при возникновении исключения в обработчике
@app.after_request
def after_request(response):
    print("after_request")
    return response


# всегда выполняется после запроса, даже если есть исключения
@app.teardown_request
def teardown_request(response):
    print('teardown_request')
    return response



# ============================================================================================================================
# COOKIES
# ============================================================================================================================
# записываются в заголовок ответа сервера
# куки хранятся открыто - в них нельзя хранить важную инфу
# куки макс 4кб

set_cookie(key, value='', max_age=None)
# key        - название куки
# value      - данные
# max_age    - необязательный аргумент времени хранения в браузере в сек. 


@app.route('/login')
def login():
    log = ""
    # если в запросе есть logged - берем из запроса
    if request.cookies.get('logged'):
        log = request.cookies.get('logged')

    # формируем ответ с передачей log
    # устанавливаем куки в logged=yes и временем хранения
    # возвращаем ответ
    res = make_response(f'{log}')
    res = set_cookie('logged', 'yes', 30*24*3600)
    return res


# max_age = 0 удаляет информацию из куки
@app.route("/logout")
def logout():
    res = make_response("Вы больше не авторизованы!</p>")
    res.set_cookie("logged", "", 0)
    return res


# КОД ШАБЛОНА HTML проверяет включены ли куки и просит пользователя их включить
<script>
    document.cookie = "ex=1;";
    if (!document.cookie)
    {
         alert("Это сайт требует включенных cookies для своей корректной работы ");
    }
</script>



# ============================================================================================================================
# SESSION
# ============================================================================================================================
# session - объект для работы с сессиями во фласке, доступный в приложении и в шаблонах
# сессии храняться в браузере пока пользователь его не закроет
# сессии шифруются с помощью ключа
# session.modified = True требует загрузки данных сессии заново. По дефолту перезагрузка происходит только при изменении session.
# session.permanent = True указывает время жизни сессий в app.permanent_session_lifetime = datetime.timedelta(days=10)

# активация работы сессий
app.config['SECRET_KEY'] = 'fdgdfgdfggf786hfg6hfg6h7f'

# генерация хорошего ключа
os.urandom(20).hex()

# сессия показывает количество просмотров главной страницы
@app.route("/")
def index():
    # если в сессии уже есть ключ - обновляем данные в сессии(прибавляем 1 просмотр)
    # если нет - создаем такой ключ со стартовым значением 1 просмотр
    if 'visits' in session:
        session['visits'] = session.get('visits') + 1  
    else:
        session['visits'] = 1
 
    return f"<h1>Main Page</h1>Число просмотров: {session['visits']}"



# ============================================================================================================================
# ШИФРОВАНИЕ ПАРОЛЕЙ
# ============================================================================================================================

from werkzeug.security import generate_password_hash, check_password_hash

# generate_password_hash() – кодирование строки данных по стандарту PBKDF2
# check_password_hash()    – проверка указанных данных на соответствие хеша
hash = generate_password_hash("12345")
check_password_hash(hash, "12345")













